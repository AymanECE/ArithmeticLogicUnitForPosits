library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.PLU_package.all;

entity Postprocessing is 
port (  
		Posit1 : in std_logic_vector(nbofbits-1 downto 0);
		Posit2 : in std_logic_vector(nbofbits-1 downto 0);
		Positt3 : in std_logic_vector(nbofbits-1 downto 0); -- this just contains the fraction bit
	    totalexponent1 : in std_logic_vector(nbofbitsforinteger downto 0 );
	    totalexponent2 : in std_logic_vector(nbofbitsforinteger downto 0 );
		nbofbitfractionn1 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofbitfractionn2 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofbitexponentt1 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofbitexponentt2 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofregimebitt1 :in std_logic_vector(nbofbitsforinteger downto 0);
		nbofregimebitt2 : in std_logic_vector(nbofbitsforinteger downto 0);
		expo1valuee : in std_logic_vector(nbofbitsforinteger downto 0);
		expo2valuee : in std_logic_vector(nbofbitsforinteger downto 0);
		cases : in std_logic_vector ( 3 downto 0 );
		Posit4 : out std_logic_vector(nbofbits-1 downto 0 ); -- this is the final output
		flag1forexponent : in std_logic;
		flag2forexponent : in std_logic;
		howmuchtoshiftsubtract : in std_logic_vector(nbofbits-1 downto 0 );
		Flag1ForSubtraction : in std_logic ;
		es : in std_logic_vector ( nbofbitsforinteger downto 0 );
		 fractionformultiplicationn : in std_logic_vector(nbofbitsformultiplication -1 downto 0 )
		);
		end Postprocessing;
		
architecture Postprocessingarchi of Postprocessing is

begin
process(Positt3,fractionformultiplicationn)

variable exponent1 : std_logic_vector(nbofbitsforinteger downto 0 ) ; 

variable exponent2 : std_logic_vector(nbofbitsforinteger downto 0 ) ; 
variable nbofbitfraction1 :  integer;
variable nbofbitfraction2 :   integer;
variable nbofbitexponent1 :  integer;
variable nbofbitexponent2 :  integer;
variable nbofregimebit1 : integer;
variable nbofregimebit2 :  integer;
variable expo1value :  integer;
variable expo2value :  integer;
variable posit3: std_logic_vector(nbofbits -1 downto 0 );
variable totalexponentt1 : integer;
variable totalexponentt2 : integer;
variable Posit4forinverse : std_logic_vector(nbofbits-1 downto 0 );
variable totalexponentt : integer;
variable modulo: integer;
variable nboffractionbits : integer;
variable nbofbitfractionaftermultiplication : integer;
variable nbofregimebits : integer;
variable fractionformultiplication : std_logic_vector(nbofbitsformultiplication -1 downto 0);
variable decrementexponent : integer;
begin


 nbofbitfraction1 := to_integer(unsigned(  nbofbitfractionn1)) ;
 nbofbitfraction2 := to_integer(unsigned(nbofbitfractionn2)) ;
 nbofbitexponent1 := to_integer(unsigned(nbofbitexponentt1)) ;
 nbofbitexponent2 := to_integer(unsigned(nbofbitexponentt2)) ;
 nbofregimebit1 := to_integer(unsigned(nbofregimebitt1)) ;
 nbofregimebit2 := to_integer(unsigned(nbofregimebitt2)) ;
 expo1value :=  to_integer(unsigned(expo1valuee)) ;
 expo2value := to_integer(unsigned(expo2valuee)) ;
posit3 := Positt3;
totalexponentt1 := to_integer(signed(totalexponent1));
totalexponentt2 := to_integer(signed(totalexponent2));


if cases ="1000" then  -- then do division

-- I am receiving the fraction part and howmuch to subtract from exponent from the PLU unit so .

                
                totalexponentt := totalexponentt1 - totalexponentt2 - to_integer(unsigned(howmuchtoshiftsubtract)); 
                
                modulo := totalexponentt mod  to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1)); -- this is the number of exponent bits
                
                
                
                
                
                 
                
                
                
                nbofregimebits := totalexponentt / to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1));
                
                
                
                
                nboffractionbits := nbofbits -1 - nbofregimebits - to_integer(unsigned(es)) - 1; 
                
                
                
                
                
                
                if ( Posit1(nbofbits-1) = '0' and Posit2(nbofbits-1) = '0'  and totalexponentt >= 0) or (Posit1(nbofbits-1) = '1' and Posit2(nbofbits-1) = '1' and totalexponentt >= 0)  then
                
                
                Posit4 <= '0' & std_logic_vector(to_signed(1,nbofregimebits)) & '0' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3(nbofbits -1 downto nbofbits - nboffractionbits );
                elsif  (Posit1(nbofbits-1) ='0' and Posit2(nbofbits-1)='0' and totalexponentt < 0 ) or (Posit1(nbofbits-1) ='1' and Posit2(nbofbits-1)='1' and totalexponentt < 0) then
                
                
                Posit4 <= '0' & std_logic_vector(to_unsigned(0,nbofregimebits)) & '1' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3( nbofbits -1 downto nbofbits-nboffractionbits  );
                
                elsif  (Posit1(nbofbits-1) ='1' and Posit2(nbofbits-1)='0' and totalexponentt >= 0 ) or (Posit1(nbofbits-1) ='0' and Posit2(nbofbits-1)='1' and totalexponentt >= 0 )  then
                Posit4forinverse := '0' & std_logic_vector(to_unsigned(0,nbofregimebits)) & '1' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3(nbofbits -1 downto nbofbits - nboffractionbits );
                Posit4 <= std_logic_vector( to_unsigned(to_integer(Not unsigned(Posit4forinverse)) + 1,nbofbits));
                else
                Posit4forinverse := '0' & std_logic_vector(to_signed(1,nbofregimebits)) & '1' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3(nbofbits -1 downto nbofbits - nboffractionbits );
                Posit4 <= std_logic_vector( to_unsigned(to_integer(Not unsigned(Posit4forinverse)) + 1,nbofbits));
                
                end if;


end if ;







 


if cases= "0100" then -- do multiplication

                        totalexponentt := totalexponentt1 + totalexponentt2; 
                        
                        modulo := totalexponentt mod  to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1)); -- this is the number of exponent bits
                        
                        totalexponentt := totalexponentt + modulo ;  -- add the modulo to get a perfect division instead ofhaving 8/3 ill have 9 /3 and then subtract a one later on
                        
                        
                        if modulo /= 0 then 
                        
                        nbofregimebits := ( totalexponentt / to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1)))-1; -- since  i added a modulo to my totalexponent thats why i need the -1 
                        
                        else 
                        
                        nbofregimebits := totalexponentt / to_integer(unsigned(es));
                        
                        end if;
                        
                        nboffractionbits := nbofbits -1 - nbofregimebits - to_integer(unsigned(es)) - 1; 
                        
                        decrementexponent :=0;


           if nbofbitfraction1 <= nbofbitfraction2 then
                        
                        fractionformultiplication := std_logic_vector(unsigned(fractionformultiplicationn) - shift_left(to_unsigned(1, (nbofbitsformultiplication)),(nbofbitfraction1*2) )) ;
                        
                        nbofbitfractionaftermultiplication := (nbofbitfraction1+1)*2;
                        posit3 := std_logic_vector(resize(shift_right(unsigned(fractionformultiplication((nbofbitfraction1*2)-1 downto 0 )),(nbofbitfraction1*2)-nboffractionbits),nbofbits));
                        
                         for i in  0 to (nbofbitfractionaftermultiplication) loop
                                               if to_integer(unsigned(fractionformultiplication)) <= to_integer(shift_left(to_unsigned(1,nbofbits),nbofbitfraction1*2)) then
                                               
                                               fractionformultiplication  := std_logic_vector(shift_left(unsigned(fractionformultiplication),1));
                                               decrementexponent := decrementexponent + 1; -- used to decrement exponent in case my i cant subtract 2^16 from the fraction.
                                               end if;
                                               end loop;      
                                if decrementexponent >= to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1)) then
                                decrementexponent := decrementexponent - to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1));
                               nbofregimebits := nbofregimebits +1;
                               modulo := modulo - decrementexponent;
                               nboffractionbits := nboffractionbits -1 ;
                               else 
                                modulo := modulo - decrementexponent;
                                end if;
                               if modulo <= 0 then 
                               modulo := 0 ;
                               end if;
                               
                                if fractionformultiplication(((nbofbitfraction1+1)*2)-1) = '1' then
                                     modulo := modulo + 1;
                                    if modulo >= to_integer(shift_left(to_unsigned(1,nbofbitfractionaftermultiplication),to_integer(unsigned(es)))) then 
                                    modulo := to_integer(shift_left(to_unsigned(1,nbofbitfractionaftermultiplication),to_integer(unsigned(es))));
                                    end if;
                                end if;
                                    
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        else
                        
                        
                        
                        fractionformultiplication  := std_logic_vector(unsigned(fractionformultiplicationn) - shift_left(to_unsigned(1, nbofbitsformultiplication),(nbofbitfraction2*2) ));
                        nbofbitfractionaftermultiplication := (nbofbitfraction2+1)*2;
                        posit3 := std_logic_vector(resize(shift_right(unsigned(fractionformultiplication((nbofbitfraction2*2)-1 downto 0)),(nbofbitfraction2*2)-nboffractionbits),nbofbits));
                        
                        
                                                
                                             for i in  0 to (nbofbitfractionaftermultiplication) loop
                                                                   if to_integer(unsigned(fractionformultiplication)) <= to_integer(shift_left(to_unsigned(1,nbofbits),nbofbitfraction2*2)) then
                                                                   
                                                                   fractionformultiplication  := std_logic_vector(shift_left(unsigned(fractionformultiplication),1));
                                                                   decrementexponent := decrementexponent + 1; -- used to decrement exponent in case my i cant subtract 2^16 from the fraction.
                                                                   end if;
                                                                   end loop;      
                                                                   
                                                     if decrementexponent >= to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1)) then
                                                        decrementexponent := decrementexponent - to_integer(shift_left(to_unsigned(2,nbofbitsforinteger),to_integer(unsigned(es))-1));
                                                              nbofregimebits := nbofregimebits +1;
                                                              modulo := modulo - decrementexponent;
                                                                nboffractionbits := nboffractionbits -1 ;
                                                                else 
                                                            modulo := modulo - decrementexponent;
                                                               end if;
                                                             if modulo <= 0 then 
                                                           modulo := 0 ;
                                                             end if;
                                            
                                                   if fractionformultiplication(((nbofbitfraction2+1)*2)-1) = '1' then
                                                    modulo := modulo + 1;
                                                        if modulo >= to_integer(shift_left(to_unsigned(1,nbofbitfractionaftermultiplication),to_integer(unsigned(es)))) then 
                                                        modulo := to_integer(shift_left(to_unsigned(1,nbofbitfractionaftermultiplication),to_integer(unsigned(es))));
                                                        end if;
                                                    end if;
                                                        
                        
                        end if;


-- I need to check the upper  two most signifcant bits of fractionformultiplication after subtracting 2^16 for instace, if i am using 16 bits then 
--fractionformultiplication will be 18 bits so i need to check bit 18, if it is one i will incremenet my exponent , i will take the bits from 0 to 15




    
                    if ( Posit1(nbofbits-1) = '0' and Posit2(nbofbits-1) = '0'  and totalexponentt >= 0) or (Posit1(nbofbits-1) = '1' and Posit2(nbofbits-1) = '1' and totalexponentt >= 0)  then
                        Posit4 <= '0' & std_logic_vector(to_signed(1,nbofregimebits)) & '0' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3(nboffractionbits-1 downto 0 );
                                       
                                       
                    elsif  (Posit1(nbofbits-1) ='0' and Posit2(nbofbits-1)='0' and totalexponentt < 0 ) or (Posit1(nbofbits-1) ='1' and Posit2(nbofbits-1)='1' and totalexponentt < 0) then
                    
                     Posit4 <= '0' & std_logic_vector(to_unsigned(0,nbofregimebits)) & '0' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3(nboffractionbits-1 downto 0 );
                                   
                    elsif  (Posit1(nbofbits-1) ='1' and Posit2(nbofbits-1)='0' and totalexponentt >= 0 ) or (Posit1(nbofbits-1) ='0' and Posit2(nbofbits-1)='1' and totalexponentt >= 0 )  then
                    Posit4forinverse := '0' & std_logic_vector(to_unsigned(0,nbofregimebits)) & '1' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3(nboffractionbits-1 downto 0 );
                    Posit4 <= std_logic_vector( to_unsigned(to_integer(Not unsigned(Posit4forinverse)) + 1,nbofbits));
                    else
                    Posit4forinverse := '0' & std_logic_vector(to_signed(1,nbofregimebits)) & '1' & std_logic_vector(to_unsigned(modulo,to_integer(unsigned(es)))) & posit3(nboffractionbits-1 downto 0 );
                    Posit4 <= std_logic_vector( to_unsigned(to_integer(Not unsigned(Posit4forinverse)) + 1,nbofbits));
END IF ;
end if;







if (cases = "0000"  or cases = "0001") then




                
            if flag1forexponent = '1' then
                
             expo1value := expo1value - to_integer(unsigned(howmuchtoshiftsubtract));
        
                if expo1value < 0 then
                expo1value := 0 ;
                end if;
             
            end if ;
        
            if flag2forexponent = '1' then
            
                expo2value := expo2value - to_integer(unsigned(howmuchtoshiftsubtract));
        
                if expo2value < 0 then
                expo2value := 0 ;
                end if;
            end if;
        exponent1 := std_logic_vector(to_unsigned(expo1value, nbofbitsforinteger+1 ));
        exponent2 := std_logic_vector(to_unsigned(expo2value, nbofbitsforinteger+1));
        
            if (totalexponentt1>totalexponentt2)  and ( Positt3(nbofbitfraction1+1) = '1')  then --This means my fraction overflowed, so add one to the value of exponent
                expo1value := expo1value+1 ; 
                exponent1:= std_logic_vector(to_unsigned(expo1value, nbofbitsforinteger+1));
                posit3 := std_logic_vector(shift_right(unsigned(Positt3),1));
                if exponent1(nbofbitexponent1) = '1' then -- my exponent value overflowed so change exponent to a series of 1s and fractions too.
                    posit3 := std_logic_vector(to_signed(-1,nbofbits));
                    exponent1 := std_logic_vector(to_signed(-1,nbofbitsforinteger+1)); 
                                                    
                    expo1value:=0 ;
                end if;
            end if;
            
            if (totalexponentt2>totalexponentt1)  and ( Positt3(nbofbitfraction2+1) = '1')  then --This means my fraction overflowed, so add one to the value of exponent
                expo2value := expo2value+1 ; 
                exponent2:= std_logic_vector(to_unsigned(expo2value, nbofbitsforinteger+1));
                posit3 := std_logic_vector(shift_right(unsigned(Positt3),1));
                if exponent2(nbofbitexponent2) = '1' then -- my exponent value overflowed so subtract one from fraction and add one to regime bits
                    posit3 := std_logic_vector(to_signed(-1,nbofbits));
                    exponent2 := std_logic_vector(to_signed(-1,nbofbitsforinteger+1));
                    expo2value :=0;
                end if;
            end if;
            
            
            if Posit1(nbofbits-2) ='0' and totalexponentt1 >=totalexponentt2  then
                Posit4forinverse := '0' & std_logic_vector(to_unsigned(0,nbofregimebit1)) & '1' & exponent1(nbofbitexponent1-1 downto 0 ) & Positt3(nbofbitfraction1-1 downto 0 );
                Posit4<= '0' & std_logic_vector(to_unsigned(0,nbofregimebit1)) & '1' & exponent1(nbofbitexponent1-1 downto 0 ) & Positt3(nbofbitfraction1-1 downto 0 );
            end if;
        
        
            if   Posit1(nbofbits-2) ='1' and totalexponentt1 >= totalexponentt2  then
            Posit4forinverse :=  '0' & std_logic_vector(to_signed(-1,nbofregimebit1)) & '0' & exponent1(nbofbitexponent1-1 downto 0 ) & Positt3(nbofbitfraction1-1  downto 0 );
                Posit4<= '0' & std_logic_vector(to_signed(-1,nbofregimebit1)) & '0' & exponent1(nbofbitexponent1-1 downto 0 ) & Positt3(nbofbitfraction1-1  downto 0 );
            end if; 
        
        
            if  Posit2(nbofbits-2) ='0' and totalexponentt2>totalexponentt1  then	
                Posit4forinverse :='0' & std_logic_vector(to_unsigned(0,nbofregimebit2)) & '1' & exponent2(nbofbitexponent2-1 downto 0 ) & Positt3(nbofbitfraction2 -1 downto 0 );
                Posit4<= '0' & std_logic_vector(to_unsigned(0,nbofregimebit2)) & '1' & exponent2(nbofbitexponent2-1 downto 0 ) & Positt3(nbofbitfraction2 -1 downto 0 );
            end if; 
        
        
        
            if  Posit2(nbofbits-2) ='1' and totalexponentt2>totalexponentt1 then	
                Posit4forinverse := '0' & std_logic_vector(to_signed(-1,nbofregimebit2)) & '0' & exponent2(nbofbitexponent2-1 downto 0 ) & Positt3(nbofbitfraction2 -1 downto 0 );
                Posit4<= '0' & std_logic_vector(to_signed(-1,nbofregimebit2)) & '0' & exponent2(nbofbitexponent2-1 downto 0 ) & Positt3(nbofbitfraction2 -1 downto 0 );
            end if; 
            
            
            
            
            
            
               if Posit1(nbofbits-1) ='1' and Posit1(nbofbits-2) ='1' and totalexponentt1 >=totalexponentt2  then
                    
                    Posit4forinverse:= '0' & std_logic_vector(to_unsigned(0,nbofregimebit1)) & '1' & exponent1(nbofbitexponent1-1 downto 0 ) & Positt3(nbofbitfraction1-1 downto 0 );
                end if;
            
            
                if  Posit1(nbofbits-1) ='1' and Posit1(nbofbits-2) ='0' and totalexponentt1 >= totalexponentt2  then
                
                   Posit4forinverse:='0' & std_logic_vector(to_signed(-1,nbofregimebit1)) & '0' & exponent1(nbofbitexponent1-1 downto 0 ) & Positt3(nbofbitfraction1-1  downto 0 );
               end if; 
            
            
                if Posit2(nbofbits-1) ='1' and Posit2(nbofbits-2) ='1' and totalexponentt2>totalexponentt1  then    
                    Posit4forinverse:= '0' & std_logic_vector(to_unsigned(0,nbofregimebit2)) & '1' & exponent2(nbofbitexponent2-1 downto 0 ) & Positt3(nbofbitfraction2 -1 downto 0 );
                end if; 
            
            
            
                if Posit2(nbofbits-1) ='1' and Posit2(nbofbits-2) ='0' and totalexponentt2>totalexponentt1 then    
                    Posit4forinverse:= '0' & std_logic_vector(to_signed(-1,nbofregimebit2)) & '0' & exponent2(nbofbitexponent2-1 downto 0 ) & Positt3(nbofbitfraction2 -1 downto 0 );
                end if; 
                
                
            if Posit1(nbofbits-1) ='1' and totalexponentt1>=totalexponentt2 then
            Posit4 <= std_logic_vector (to_unsigned(to_integer( Not unsigned(Posit4forinverse))+1,nbofbits));
            end if;
                if Posit2(nbofbits-1) ='1' and totalexponentt2>totalexponentt1 then
             Posit4 <= std_logic_vector (to_unsigned(to_integer( Not unsigned(Posit4forinverse))+1,nbofbits));
                end if;
                
                if Flag1ForSubtraction ='1' then -- So this mean my PLU did B- A but my A is bigger, or A- B but B is bigger
                 Posit4 <= std_logic_vector (to_unsigned(to_integer( Not unsigned(Posit4forinverse))+1,nbofbits));
                end if;
end if;
end process;

end Postprocessingarchi ;

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.PLU_package.all;
entity testbench_PostProcessing is

end testbench_PostProcessing;

architecture behavioral of testbench_PostProcessing is


component PostProcessing
-- 
port (  
		Posit1 : in std_logic_vector(15 downto 0);
		Posit2 : in std_logic_vector(15 downto 0);
		Positt3 : in std_logic_vector(15 downto 0); -- this just contains the fraction bit
	    totalexponent1 : in std_logic_vector(15 downto 0 );
	    totalexponent2 : in std_logic_vector(15 downto 0 );
		nbofbitfractionn1 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofbitfractionn2 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofbitexponentt1 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofbitexponentt2 : in std_logic_vector(nbofbitsforinteger downto 0);
		nbofregimebitt1 :in std_logic_vector(nbofbitsforinteger downto 0);
		nbofregimebitt2 : in std_logic_vector(nbofbitsforinteger downto 0);
		expo1valuee : in std_logic_vector(nbofbitsforinteger downto 0);
		expo2valuee : in std_logic_vector(nbofbitsforinteger downto 0);
		cases : in std_logic_vector ( 2 downto 0 );
		Posit4 : out std_logic_vector(15 downto 0 ) -- this is the final output
		);
end component;

 signal       Posit1 : std_logic_vector(15 downto 0);
 signal		Posit2 : std_logic_vector(15 downto 0);
 signal		Positt3 :  std_logic_vector(15 downto 0); -- this just contains the fraction bit
 signal	    totalexponent1 :  std_logic_vector(15 downto 0 );
 signal	    totalexponent2 :  std_logic_vector(15 downto 0 );
 signal		nbofbitfractionn1 :  std_logic_vector(nbofbitsforinteger downto 0);
 signal		nbofbitfractionn2 :  std_logic_vector(nbofbitsforinteger downto 0);
 signal		nbofbitexponentt1 :  std_logic_vector(nbofbitsforinteger downto 0);
 signal		nbofbitexponentt2 :  std_logic_vector(nbofbitsforinteger downto 0);
 signal		nbofregimebitt1 : std_logic_vector(nbofbitsforinteger downto 0);
 signal		nbofregimebitt2 :  std_logic_vector(nbofbitsforinteger downto 0);
 signal		expo1valuee :  std_logic_vector(nbofbitsforinteger downto 0);
 signal		expo2valuee :  std_logic_vector(nbofbitsforinteger downto 0);
 signal		cases :  std_logic_vector ( 2 downto 0 );
 signal		Posit4 :  std_logic_vector(15 downto 0 );


begin

U2: Postprocessing port map( Posit1 => Posit1,
Posit2=> Posit2,
Positt3=> Positt3,
totalexponent1 => totalexponent1,
totalexponent2 => totalexponent2,
nbofbitfractionn1 =>nbofbitfractionn1,
nbofbitfractionn2 =>nbofbitfractionn2,
nbofbitexponentt1 =>nbofbitexponentt1,
nbofbitexponentt2 =>nbofbitexponentt2,
nbofregimebitt1 =>nbofregimebitt1,
nbofregimebitt2 =>nbofregimebitt2,
expo1valuee =>expo1valuee,
expo2valuee =>expo2valuee,
cases =>cases,
Posit4 =>Posit4
);


process

begin 

wait for 100ns;
Posit1 <= "0111100101001011";
Posit2 <= "0111011001110110";
Positt3 <= "0000000001010110";
totalexponent1 <=   "0000000000100010"; --x"00022"; 
totalexponent2 <=   "0000000000011110"; --x"0001e";
nbofbitfractionn1 <=  "00000000000000111";--x"00007";
nbofbitfractionn2 <=  "00000000000001000";--x"00008";
nbofbitexponentt1 <= "00000000000000011";--x"00003" ;
nbofbitexponentt2 <=  "00000000000000011";--x"00003";
nbofregimebitt1 <=  "00000000000000100";--x"00004";
nbofregimebitt2 <=  "00000000000000011";--x"00003";
expo1valuee <=  "00000000000000010";--x"00002"; 
expo2valuee <=  "00000000000000110";--x"00006";
cases <= "000";
wait for 100ns;


end process;

end Behavioral;
